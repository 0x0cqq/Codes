

树堆（英语：Treap），是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为O(\log{n})。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。
<!-- more -->

## 基本思想及操作
一般在treap里面维护一个最小堆。
### 旋转
旋转是一种不破坏二叉搜索树性质的操作，有左旋及右旋两种。具体操作见图。
旋转的时间复杂度是O(1)，因为只需要修改常数个指针。
![]()

### 按关键字寻找
可以发现，在要寻找的关键字小于当前节点关键字时，其节点只可能在当前节点的左子树中；等于时即为当前节点；大于时候在右子树中。于是可以根据关键字寻找到节点。

### 插入
在treap中，插入需要根据二叉搜索树的性质，找到能放置这个节点的空位置，给新节点随机分配一个优先值，然后调整treap的堆性质。

### 删除
如果需要删除一个节点，首先应当寻找到这个节点，并将这个节点旋转至最底层，即左右儿子皆为空的时候，删除该节点。并注意需要在旋转过程中维护最小堆性质。

### 查询排名
在这里排名是指小于某数的数的个数+1。注意到在某二叉搜索树中，小于根节点的节点数目即为根节点左子树的节点数目。所以只需要按关键字查找到此节点，并如果向右搜索，就加上此节点左子树的大小和根节点的大小，进行递归搜索。

### 按排名查找
需要对每一个节点维护一个size值，意为以其为根节点的树的大小（包括本身）。搜索的时候，如果排名小于当前节点左子树的size值直接递归进入左子树；如果排名落在当前节点，则返回当前节点；否则更新排名向右子树递归。

### 前驱&后继
在这里，前驱定义为小于x，且最大的数。后继同理。这个的寻找稍微复杂。
以前驱为例。

如果寻找到的节点有左子树，那么其前驱就是左子树里面的最大值；如果没有左子树，那么其前驱就是寻找的路径上最靠近的一个向右寻找的节点。

第一种很容易想明白，第二种稍难一些。

以此图为例。比如我们寻找7的前驱，它没有左子树，所以它属于情况二。按照刚才提到的规则，可以发现7的前驱是6，因为6是最后一个向右寻找，即下一次寻找是其右儿子（7）。

可以注意到，6的左子树上的点全都比6小，不符合要求；7的左子树不存在，7的右子树上的点都比7大，而6-7的路径上的点（假装有点，其应当是全都是向左寻找的，也都比7要大，而在6以上的点，应当都比7要大（6是左儿子的时候），或者比6要小（6是右儿子的时候），所以，6就是7的前驱。

后继同理。

以上操作的期望时间复杂度都是O(\log{n})。

### 另一些需要注意的事项



## 代码
以洛谷P3369普通平衡树为例。代码是指针版，不记录父节点，递归操作，有轻微压行，采用java换行风格。

（其实我还是觉得数组好写

### 结构体的定义
```cpp
template<typename T,size_t siz>
struct treap{
    struct node_t{
        T val;
        int p,size,cnt;
        node_t *son[2];
    };
    int treapcnt;
    node_t pool[siz<<1],*root,*null;
```
在这里采用了模板的定义方法。T为一个模版类。需要注意这里的T模板要有小于运算符。

对于每一个节点，我们维护以下几个信息：关键字，随机优先值，以其为根的二叉搜索树的大小，和这个关键字的数量，左儿子和右儿子的指针。默认0为左，1为右。

在结构体的变量中，我们维护了一个静态内存池，内存池已经使用的数量，根节点的指针，以及一个虚的空节点。

在这里自己定义一个空节点的好处主要是可以避免```NULL```导致的segmentation fault，以及让函数编写变得更加简单。

需要注意的是，视题目不同，```cnt```变量可能可以省去。

### 一些简单函数
```cpp
    void newnode(node_t *&r){
        r = &pool[treapcnt++];
        r->son[0] = r->son[1] = null;
    }
    void update(node_t *r){
        r->size = r->son[0]->size + r->son[1]->size + r->cnt;
    }
```
newnode函数在这里完成对节点初始化的任务，并对子节点赋值。需要注意以下，这里需要使用引用的方法，否则如果使用了返回值的办法，就不能使用newnode函数对null赋值了，因为会产生```NULL```这种可怕的东西。其实在这里也可以把赋关键字、随机值、size值等事情一并完成，但是我比较懒，所以就在后面手动赋值了。

update函数在这里完成对节点size值的更新，很好理解。

### 结构体的初始化
```cpp    
    treap(){
        treapcnt = 0;
        newnode(null);
        null->size = null->val = 0;
        null->p = MAXINT;
        root = null;
        srand(time(NULL));
    }
```

结构体的初始化不难，有几点需要注意：
+ 空指针的size需要为0，val其实无所谓
+ 空指针的随机值需要**足够大**，最好是maxint，否则有可能在之后的删除操作中被转上去，然后树就断了
+ 最好srand一下，不过不srand关系也不大

### 旋转
```cpp
    void rotate(node_t *&r,int tmp){//0左旋，1右旋
        node_t *t = r->son[1-tmp];  //找到需要旋上来的节点
        r->son[1-tmp] = t->son[tmp];//将被选节点的被遮蔽的儿子交给上面的节点
        t->son[tmp] = r;            //将r作为t的儿子
        update(r),update(t);        //注意更新顺序！先儿子后父亲
        r = t;                      //通过引用更改上方节点的儿子
    }
```
![]()
旋转操作的文字叙述：

1. 选定当前节点r
2. 找到并记录需要旋上来的节点t（左旋旋右儿子，右旋左儿子）
3. 把t将要被覆盖的儿子（与旋转方向相同的儿子）接到t在r原来的位置上
4. 把r接到t空出来的位置上

其实这个记不下来不要紧。大概有个印象，要写的时候根据二叉搜索树的性质现推也可以其实。（误

